<html><head><title>Fable Blog</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:title" content="Fable"/><meta name="twitter:description" content="F# to JS compiler"/><meta name="twitter:image" content="https://fable.io/img/fable_logo.png"/><meta name="twitter:card" content="summary_large_image"/><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Josefin+Sans:400,300,600,700|Roboto+Mono|Fira+Code|Open+Sans:400,300,600,700"/><script src="https://kit.fontawesome.com/f1c8a90b9d.js"></script><link rel="stylesheet" type="text/css" href="/css/styles.css"/><link rel="stylesheet" type="text/css" href="/css/prism.css"/><link rel="shortcut icon" href="/img/fable.ico"/></head><body><nav class="navbar"><div class="navbar-brand"><a class="navbar-item is-size-4" href="/" style="background-color:rgba(0,0,0,0.5);color:dodgerblue;font-weight:600">Fable</a><div class="navbar-burger" data-target="navMenu"><span></span><span></span><span></span></div></div><div id="navMenu" class=" navbar-menu"><div class="navbar-start"><a class=" navbar-item" href="/docs">Docs</a><a class=" navbar-item is-active" href="/blog">Blog</a><a class=" navbar-item" href="/repl">REPL</a><a class=" navbar-item" href="/community">Community</a><a class=" navbar-item" href="/fableconf">FableConf</a></div><div class="navbar-end"><div class="field is-grouped"><a class="navbar-item" href="https://gitter.im/fable-compiler/Fable" target="_blank" style="color:white"><span class="icon"><i class=" fab fa-gitter"></i></span></a><a class="navbar-item" href="https://github.com/fable-compiler/fable" target="_blank" style="color:white"><span class="icon"><i class=" fab fa-github"></i></span></a><a class="navbar-item" href="https://twitter.com/FableCompiler" target="_blank" style="color:white"><span class="icon"><i class=" fab fa-twitter"></i></span></a><a class="navbar-item" href="https://www.youtube.com/channel/UC6m70Jyr65ogDySbK7aMmzg/videos" target="_blank" style="color:white"><span class="icon"><i class=" fab fa-youtube"></i></span></a></div></div></div></nav><div class="markdown blog" style="overflow:hidden"><div class="fable-header-minimal"><figure class="image" style="max-width:200px;margin:20px auto"><img class="fable-logo" src="/img/fable_logo.png"/></figure></div><div style="margin-top:1.6rem"><div class="columns"><div class="column"></div><div class="column is-two-thirds"><div class="post_date" style="margin:5px;margin-bottom:2em"><i class=" far fa-calendar"></i> June 02, 2021</div><div class="content" style="margin:5px"><h2><a name="introducing-snowflaqe" class="anchor" href="#introducing-snowflaqe">Introducing Snowflaqe</a></h2><p>In this blog post, we will introduce a new tool for Fable called <a href="https://github.com/Zaid-Ajaj/Snowflaqe">Snowflaqe</a> which will allow generating type-safe GraphQL clients for Fable applications. Though at first, let us talk about what the problem is that Snowflaqe solves and why it is needed.</p>
<h3><a name="graphql-backends" class="anchor" href="#graphql-backends">GraphQL Backends</a></h3><p>While most web applications implement data exchange protocols between backend and frontend as a traditional REST API or some (g)RPC library, many modern applications have been implementing their backend API with <a href="https://graphql.org/">GraphQL</a> instead. Exposing a GraphQL API enables a rich and easy to use query language for different frontends and different clients. GraphQL has been very popular especially in the node.js community and it is now gaining momentum in .NET via the excellent <a href="https://github.com/graphql-dotnet/graphql-dotnet">graphql-dotnet</a> library and other platforms as well.</p>
<h3><a name="type-safe-grapql-clients" class="anchor" href="#type-safe-grapql-clients">Type-Safe GrapQL Clients</a></h3><p>When a client communicates with a GraphQL backend, it sends a query. The query must has to be compatible with the exposed GraphQL schema from the backend in order to return the requested data (much like SQL queries).</p>
<p>The shape and structure of the data is very much dependent on the written query. This means that data returned from a query has a unique shape. For example, the following query:</p>
<pre><code>query {
    posts {
        id
        title
        author {
            firstName
            lastName
        }
    }
}</code></pre><p>Might map to F# types as follows:</p>
<pre><code class="language-fs"><span class="token builtin class-name">type</span> Author <span class="token operator">=</span> <span class="token punctuation">{</span>
    firstName: string option
    lastName: string option
<span class="token punctuation">}</span>

<span class="token builtin class-name">type</span> Post <span class="token operator">=</span> <span class="token punctuation">{</span>
    id: string
    title: string
    author: Author
<span class="token punctuation">}</span>

<span class="token builtin class-name">type</span> Query <span class="token operator">=</span> <span class="token punctuation">{</span>
    posts: Post list
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>The types are of course imaginary here and are for demo purposes.</p>
</blockquote>
<p>Adding or removing properties from the query changes the type of the shape of data that is returned.
Modelling the shape of the queries via F# types by hand can be a cumbersome task and is very error-prone: you as a developer have to lookup the individual types and making sure these align with the schema every time the schema changes.</p>
<h3><a name="type-providers-to-the-rescue-" class="anchor" href="#type-providers-to-the-rescue-">Type-Providers to the rescue...?</a></h3><p>The first idea that F# developers get when looking at such problem is: &quot;There must be a type provider for this!&quot; and they would be right. In F# land, the awesome <a href="https://github.com/fsprojects/FSharp.Data.GraphQL">FSharp.Data.GraphQL</a> library gives the ability to write GraphQL backends and includes a type provider for type-safe clients in F#. However, unfortunately since Fable 2.0 came out a long time ago around late 2018, the type provider <a href="https://github.com/fsprojects/FSharp.Data.GraphQL/issues/204">has been incompatible</a> with Fable applications. I thought I could give it a try and fix the problem in the repository, even the maintainer <a href="https://github.com/johnberzy-bazinga">John Berzy</a> generously offered to help out but I couldn&#39;t get my head around the code base: type providers are really hard to write and to understand what exactly they are doing. Not to mention, I didn&#39;t enough experience in GraphQL itself to understand how the mapping worked by that time.</p>
<h3><a name="snowflaqe-code-gen-back-to-business" class="anchor" href="#snowflaqe-code-gen-back-to-business">Snowflaqe: code-gen back to business</a></h3><p>Instead of a type-provider, I thought I would start fresh from a new perspective and instead try to implement what many tools in the node.js ecosystem do: code-generate the client application! This is essentially what <a href="https://github.com/Zaid-Ajaj/Snowflaqe">Snowflaqe</a> does: it generates a fully functional F# <em>project</em> that can be referenced from Fable applications. The generation process uses a URL to the GraphQL backend to retrieve the schema from and an input directory containing the individual queries. The tool will first <em>validate</em> and <em>type-check</em> the queries against the schema and when everything is good, it starts to generate the actual project.</p>
<p>Snowflaqe is currently at v1.0 and it is distributed as a dotnet CLI tool, you can give it a try by installing it on your machine:</p>
<pre><code>dotnet tool install snowflaqe -g</code></pre><p>If you wanted to build a GraphQL front-end using latest Fable, now you can. The tool is still very much in early days and I have only been developing it for the last 3 weeks. I used it at work for one of our Fable projects that talks to a GraphQL backend using complex queries and it works like a charm, I was really happy with the results. In case you have a project to try it out too, I am curious to hear your feedback.</p>
<blockquote>
<p>Currently Snowflaqe only supports Fable projects but in the future I plan to allow for other specialized generation targets such as F# on dotnet or on WebAssembly via <a href="https://fsbolero.io/">Bolero</a>. As always, PRs are welcome!</p>
</blockquote>
<p>You can learn more about Snowflaqe by reading the <a href="https://github.com/Zaid-Ajaj/Snowflaqe">docs on Github</a></p>
<p>I hope you enjoy using Snowflaqe.</p>
<p>Happy coding!</p>
</div></div><div class="column"></div></div></div></div><footer style="background-color:dodgerblue"><div class="content"><p>Fable <a href="https://github.com/fable-compiler/Fable">source code</a> is licensed <a href="http://opensource.org/licenses/mit-license.php">MIT</a>.</p></div></footer><script>
document.addEventListener('DOMContentLoaded', function () {
  // burger
  var $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  if ($navbarBurgers.length > 0) {
    $navbarBurgers.forEach(function ($el) {
      $el.addEventListener('click', function () {
        var target = $el.dataset.target;
        var $target = document.getElementById(target);
        $el.classList.toggle('is-active');
        $target.classList.toggle('is-active');
      });
    });
  }
});</script></body></html>