This is the third post in the "Announcing Nagareyama (Fable 3)" series. You can check the previous articles below:

- [Announcing Nagareyama I: Tooling](https://fable.io/blog/Announcing-Nagareyama-1.html)
- [Announcing Nagareyama II: Code Generation](https://fable.io/blog/Announcing-Nagareyama-2.html)

This time we will be focusing on the actual new features of Nagareyama. There are not so many because we've been focusing on the tooling improvements for this release, but there are still a couple of interesting surprises so let's go through them together!

## Plugins!

Plugins are probably the most important new feature in Fable 3 but they're actually a comeback: Fable 1 already supported them. Unfortunately, their design was not good and only a few users could take some advantage of them. Because of this, plugins were removed during the Fable 2 rewrite. We hope the design issues have been fixed and we are confident plugins are going to be much more useful to Fable developers.

Why does Fable need plugins? Because one of Fable's goals is to interop well with JS code and tooling. Sometimes, JS tooling expects code to be written in a particular way that differs to the code generated by Fable. This poses a dilemma when developing the compiler: Do we change the code generation to fit this particular tool? Or do we add some magic for the specific use case, likely complicating things both for Fable maintainers and users? Or do we try to resolve the problem with code even if it results in non-idiomatic F# or conflicts with the type-checker?

Plugins are a way to solve this dilemma: we can add some magic to manipulate the generated code for this specific case, while keeping the Fable codebase cleaner. The most obvious example and the first plugin of the Nagareyama-gen are React components. On first sight, [React function components](https://en.reactjs.org/docs/components-and-props.html#function-and-class-components) look very similar to F# code. I will spare you of the details (you can have a look at this [long discussion](https://github.com/fable-compiler/fable-react/pull/188) if interested) but there are actually many nuances that have caused many problems. Last week at .NET Conf, [Zaid Ajaj](https://twitter.com/zaid_ajaj) presented a new way of creating React components simply by decorating a function with an attribute using Nagareyama plugins, as in:

```fsharp
[<ReactComponent>]
let counter() =
    let (count, setCount) = React.useState(0)
    Html.div [
        prop.style [ style.padding 20 ]
        prop.children [
            Html.h1 count
            Html.button [
                prop.text "Increment"
                prop.onClick (fun _ -> setCount(count + 1))
            ]
        ]
    ]
```

If you haven't [watched his presentation yet](https://www.youtube.com/watch?v=a6Ct3CM_lj4), please do it. It's a great introduction to creating React apps using F# and [Feliz](https://zaid-ajaj.github.io/Feliz/) and Zaid is an awesome presenter!

## Witnesses

It may be a hard-sell to promote this as a new feature, as it is something "hidden" int the F# compiler and you probably won't notice it all in your Fable code. It is however, one of the biggest improvements in Fable 3 and it has to do with [SRTP](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters) resolution. So far, SRTP were resolved internally by the F# compiler in an opaque way, and because of this Fable and other F#-to-X compilers had to do their own resolution, rendering different results in some situations. Don Syme has been working a lot to change this and now, thanks to the witnesses the F# compiler exposes the information necessary to make sure Fable resolves SRTP in the same way F# does and avoiding compilation errors because of the use of advanced patterns. You can read more about [witnesses in F# here](https://github.com/fsharp/fslang-design/blob/master/FSharp-5.0/FS-1071-witness-passing-quotations.md).

## Mangle interfaces

If you've read the documentation about [calling Fable code from JS](https://fable.io/docs/communicate/fable-from-js.html#Name-mangling) or inspected the generated JS code, you'll know that Fable detaches and mangles instance members. This is necessary for several reasons like overload resolution or tree shaking. But an exception, interface members, was introduced to make interop with JS easier. Thanks to this, in order to type an object or module coming from JS we just need to declare an interface (as [ts2fable](https://fable.io/ts2fable/) does) without any special syntax. On the other hand, this imposes some limitations: interface members cannot be overloaded and we cannot implement two or more interfaces when the member names conflict.

To overcome this limitations, Nagareyama introduces the `Mangle` attribute which can be used to decorate interfaces that won't be used to interop with JS and can safely be mangled, as you can see in this [rather contrived example in the REPL](https://fable.io/repl3/#?code=PYBwpgdgBAygngZwC5gLYFgBQpJQGICGARgDZgB0AwsAE5hZYDaAPALIEQDmZAfALpYkccFABCBGgEkIKGgDMCAYzBQAvFiiaoxZDSVIxEgFxRdASy5QA7maQALKJzBIANKecatOpHsUGAIsAwwKjOdhacJnImABRyJMAEBgC0PFDxiSlpGUkAlFAAVFAAblEJSVCp6eVInprevgaSKKgmFllQinYS1rYOTq7utZha2kS6+lDNaCZdPVVEwMAkvfaOHiNe4z6TMACurVAsAAoSBKgAgjR6cPxQtmgIJuZcjHyVaS+cDJgsF9uNSgkAgIBD8QTCFTiGj-CZ+IEghAxAAeZUy+XUm00oVQRDANCgAH1yAA1AgkPYqVRQZF1KA4vEE4mBYKhewRFFuOAYmmFIpwOkNSYskJhCJoipVHLDCEiaEI0EojF0ix2fG2QwwgH6BVIgCMAAZyLk6WQDKg9khiGRedTaVioMBiviaGYACYqdkIcgitnhLhKtR00Zen1BUXsgPItyhskUsAmh3tfEKZSa6SyVMqGz2YNaBn4onkaGrfrOGI85HaCBuoYxblqXnMZJQAUO0YFgmh31igNyNzI5Xt0ZaM3pRtyGl5kdQMdV6mTgAs5AArNOR2O4BOoAB2cjrkPhb09yOcFGVVuJmfYtCMovTVCl9ZIGJmSvkRhmd4cWsIZz3TpGyrZsaXIAAVYBKG6GFrgIOAKygAAfNIrhuchUAIEAzCgOI9mgMwACZOiIqozEnbDqUIqB7FwRQoDAEg-2I-JkNgHwInXTt7xaJ8BhiRR3wgqCJFQuCENY0S4HIMBkTMZAEBwmJVHyATONvQtiX2VBXxaBAeUk8g6DdPY01w6Aqy3KoqwAal5Wyt3s-IHlQBAfjHFBkBwodRjHAg3TdY4KQQIiLKAqB7PCqACP3B0xwtEgkDMEASDgMCbDTUK7UKVtsrbHz-yICQiOpeVgUVAAiaFyvyIw0mhDMUyUegHUKmhosYA13hAgByAAtbq6Va6KSxAobix6WyxpPf0zz8gKgoItwAGZjXAoJ2IDcq8AI6rIrGxgCL4NaYA2s98lsmIEBAV0ZEncqAFIiEe8qoH27rRG6943uRT6ry0MaRpbAGJteoryC0mJyoIcq3HKohFBhqByrdarBrBktWOu9o5GgB6EBegB6AmoF6iQAE4VyWgA2cgd0XeRyT-BRGLAAhiEUeG2fh+H-J+DyX0TIA&html=DwCwLgtgNgfAUHUBTAhgE3gAm54ElgqbhgAOAtEgI4CuAlgG4C8A5AMID2AdmEj+QBUAnqSQtMAY268erXgA8wAenDQA3JJAoATgGcCTGmABm5ABwssOYLona6pMJl3aJTAEQB9TwAkA8gDKAt5KUHQARrpK2qgSYAB0pNocaDRxdNzxEHRc8QBWuu4wwEq29o5W2DZ2Dk4ubl6+gcGeoRFRMShx5GgcEInJqemZ2bkFRSVltZWYiFOOzq4eJKS6AFxKSjRcpADWAObxUhBKAAIA7kjhx6TcfGBRl9d9t1z3ugWnAEzxAAzxAGYlBIaLowH1KFAkPgeLpKLoAKzkdAoRxIbT5QrFUo1CpzXF1JbuFbrTbbPaHY5nJ43O6w4Gg8EQSHQ96nACM8R+vwZYIhSChMIeWRymImOPKYHg1UliwaJI2Wx2ByOfWpV1pb3pui0aCEvQgHPinKBOvQ+r6IrGWMmBPgCBKIFQGAd4RSQkkUBQul0HlRFCkPBQOXRRTgOFwECE5HCRnBXEwXvCAo8HA44qjMbj3GlSjdevtjsgsDgQA&css=BYFwtgNgNAUARgewCYE8AEBvGadoGYIB2IAtAM4CWAXgKYBcaAjAGwAOAHgNwwC+MMAOjABDCoRIBjIiFGEaAJ0zZcSCmVYRhKBngg0uynAHcKSEMAaMADFYCk3XGmA0KAc1CWb9w2gBWAVzIQCjwUSWkaYgYJSJAFB1xhCDdxCjiwMmjY+J9dfRJVeRoJYKJohAh-MEJuPkExVn8QJUdWYSRVQlcGAQAmAFYisAScAmJyanomNgNHEzMLNAGrDhG0EXlXMRJEEBAEMEsh2pggA).

> Please note by default interface members will still NOT be mangled, so interop with JS won't break.

In order to use the `Mangle` attribute you need to use a prerelease version of Fable.Core, though we are considering to publish the new Fable.Core as a minor release when Fable 3 is out as there are no breaking changes.

## Emit JS helpers

There are two attributes Fable developers use often when interacting with JS code: `Import` and `Emit`. You can read more about them [here](https://fable.io/docs/communicate/js-from-fable.html).

In the case of the `Import` attribute, Fable.Core also provides function helpers to get a somewhat cleaner syntax.

```fsharp
open Fable.Core
open Fable.Core.JsInterop

// Instead of...
[<ImportMember("my-module")>]
let myFunction(x: int): int = jsNative

// We can do...
let myFunction(x: int): int = importMember "my-module"
```

In the case of emitting JS this was not balanced. Nagareyama resolves this by also including function helpers to emit JS raw strings, with the same [replacement rules for arguments](https://fable.io/docs/communicate/js-from-fable.html#Emit-when-F-is-not-enough) as with the attributes. A big difference with the attributes is the code will be emitted in the declaring site instead of the call site.

```fsharp
let measureTime (f: unit -> unit) = emitJsStatement f """
   const startTime = process.hrtime();
   $0();
   const elapsed = process.hrtime(startTime);
   console.log("Ms:", elapsed[0] * 1e3 + elapsed[1] / 1e6);
"""

// Note we can pass multiple arguments with a tuple
let addAnything (x: obj) (y: obj): obj = emitJsExpr (x, y) "$0 + $1"
```

As usual, we don't recommend relying on inlined JS code too much, after all, Fable was developed to be able to use and advanced statically-typed language with the JS ecosystem, but sometime we just need to paste a piece of code we borrowed from the internet (we don't do that very often, but sometimes happens, right?) and the new helpers make this easier than using the attributes. 

A word of caution about emitting _raw_ javascript. Fable 2 relied on Babel to parse this raw code and integrate it with JS AST. Now Fable 3 prints this code directly, which surfaces a problem we don't have in F#: in JS as in other languages, there's a difference between "expressions" and "statements". Fable 3 won't be able to tell them apart from a JS code string. That's why there are two helpers: `emitJsExpr` and `emitJsStatement`. The `Emit` attribute also includes now an optional `isStatement` parameter:

```fsharp
// `debugger` can only appear in statement in JS
[<Emit("debugger", isStatement=true)>]
let stopDebugger(): unit = jsNative
```

Again, while Fable 3 is prerelease you'll have to also download a prerelease version of Fable.Core in order to use the new Emit helpers.

<br />

We've just published the (hopefully) latest release candidate. If you're already using Nagareyama please update to latest version and test that everything is fine. If there are no critical reports in the upcoming days, we will re-publish this as the official Fable 3 release! Exciting times ahead!
