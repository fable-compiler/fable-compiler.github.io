{"version":3,"sources":["../../samples/browser/virtualdom/node_modules/fable-import-virtualdom/Fable.Helpers.Virtualdom.fs"],"names":[],"mappings":"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","file":"Fable.Helpers.Virtualdom-1273792215.js","sourceRoot":"/Users/alfonsogarciacaronunez/Documents/Github/Fable/temp","sourcesContent":["module Fable.Helpers.Virtualdom\n\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen System.Diagnostics\n\n[<Import(\"h\",\"virtual-dom\")>]\nlet h(arg1: string, arg2: obj, arg3: obj[]): obj = failwith \"JS only\"\n\n[<Import(\"diff\",\"virtual-dom\")>]\nlet diff (tree1:obj) (tree2:obj): obj = failwith \"JS only\"\n\n[<Import(\"patch\",\"virtual-dom\")>]\nlet patch (node:obj) (patches:obj): Fable.Import.Browser.Node = failwith \"JS only\"\n\n[<Import(\"create\",\"virtual-dom\")>]\nlet createElement (e:obj): Fable.Import.Browser.Node = failwith \"JS only\"\n\nmodule Html =\n    [<AutoOpen>]\n    module Types =\n        type EventHandler<'TMessage> = string*(obj -> 'TMessage)\n\n        type Style = (string*string) list\n\n        type KeyValue = string*string\n\n        type Attribute<'TMessage> =\n            | EventHandler of EventHandler<'TMessage>\n            | Style of Style\n            | Property of KeyValue\n            | Attribute of KeyValue\n\n        type Element<'TMessage> = string * Attribute<'TMessage> list\n        /// A Node in Html have the following forms\n        type VoidElement<'TMessage> = string * Attribute<'TMessage> list\n        type DomNode<'TMessage> =\n        /// A regular html element that can contain a list of other nodes\n        | Element of Element<'TMessage> * DomNode<'TMessage> list\n        /// A void element is one that can't have content, like link, br, hr, meta\n        /// See: https://dev.w3.org/html5/html-author/#void\n        | VoidElement of VoidElement<'TMessage>\n        /// A text value for a node\n        | Text of string\n        /// Whitespace for formatting\n        | WhiteSpace of string\n        | Svg of Element<'TMessage> * DomNode<'TMessage> list\n\n    let mapEventHandler<'T1,'T2> (mapping:('T1 -> 'T2)) (e,f) = EventHandler(e, f >> mapping) \n\n    let mapAttributes<'T1,'T2> (mapping:('T1 -> 'T2)) (attribute:Attribute<'T1>) =\n        match attribute with\n        | EventHandler(eb) -> mapEventHandler mapping eb\n        | Style s -> Style s\n        | Property kv -> Property kv\n        | Attribute kv -> Attribute kv \n\n    let mapElem<'T1,'T2> (mapping:('T1 -> 'T2)) (node:Element<'T1>) =\n        let (tag, attrs) = node\n        (tag, attrs |> List.map (mapAttributes mapping))\n\n    let mapVoidElem<'T1,'T2> (mapping:('T1 -> 'T2)) (node:Element<'T1>) =\n        let (tag, attrs) = node\n        (tag, attrs |> List.map (mapAttributes mapping))\n\n    let rec map<'T1,'T2> (mapping:('T1 -> 'T2)) (node:DomNode<'T1>) = \n        match node with\n        | Element(e,ns) -> Element(mapElem mapping e, ns |> List.map (map mapping))\n        | VoidElement(ve) -> VoidElement(mapVoidElem mapping ve)\n        | Text(s) -> Text s \n        | WhiteSpace(ws) -> WhiteSpace ws   \n        | Svg(e,ns) -> Element(mapElem mapping e, ns |> List.map (map mapping))\n\n    [<AutoOpen>]\n    module Tags =\n        let inline elem tagName attrs children = Element((tagName, attrs), children)\n        let inline voidElem tagName attrs = VoidElement(tagName, attrs)\n\n        let inline whiteSpace x = WhiteSpace x\n        let inline text x = Text x\n\n        // Elements - list of elements here: https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n        // Void elements\n        let inline br x = voidElem \"br\" x\n        let inline area x = voidElem \"area\" x\n        let inline baseHtml x = voidElem \"base\" x\n        let inline col x = voidElem \"col\" x\n        let inline embed x = voidElem \"embed\" x\n        let inline hr x = voidElem \"hr\" x\n        let inline img x = voidElem \"img\" x\n        let inline input x = voidElem \"input\" x\n        let inline link x = voidElem \"link\" x\n        let inline meta x = voidElem \"meta\" x\n        let inline param x = voidElem \"param\" x\n        let inline source x = voidElem \"source\" x\n        let inline track x = voidElem \"track\" x\n        let inline wbr x = voidElem \"wbr\" x\n\n        // Metadata\n        let inline head x = elem \"head\" x\n        let inline style x = elem \"style\" x\n        let inline title x = elem \"title\" x\n\n        // Content sectioning\n        let inline address x = elem \"address\" x\n        let inline article x = elem \"article\" x\n        let inline aside x = elem \"aside\" x\n        let inline footer x = elem \"footer\" x\n        let inline header x = elem \"header\" x\n        let inline h1 x = elem \"h1\" x\n        let inline h2 x = elem \"h2\" x\n        let inline h3 x = elem \"h3\" x\n        let inline h4 x = elem \"h4\" x\n        let inline h5 x = elem \"h5\" x\n        let inline h6 x = elem \"h6\" x\n        let inline hgroup x = elem \"hgroup\" x\n        let inline nav x = elem \"nav\" x\n\n        // Text content\n        let inline dd x = elem \"dd\" x\n        let inline div x = elem \"div\" x\n        let inline dl x = elem \"dl\" x\n        let inline dt x = elem \"dt\" x\n        let inline figcaption x = elem \"figcaption\" x\n        let inline figure x = elem \"figure\" x\n        let inline li x = elem \"li\" x\n        let inline main x = elem \"main\" x\n        let inline ol x = elem \"ol\" x\n        let inline p x = elem \"p\" x\n        let inline pre x = elem \"pre\" x\n        let inline section x = elem \"section\" x\n        let inline ul x = elem \"ul\" x\n\n        // Inline text semantics\n        let inline a x = elem \"a\" x\n        let inline abbr x = elem \"abbr\" x\n        let inline b x = elem \"b\" x\n        let inline bdi x = elem \"bdi\" x\n        let inline bdo x = elem \"bdo\" x\n        let inline cite x = elem \"cite\" x\n        let inline code x = elem \"code\" x\n        let inline data x = elem \"data\" x\n        let inline dfn x = elem \"dfn\" x\n        let inline em x = elem \"em\" x\n        let inline i x = elem \"i\" x\n        let inline kbd x = elem \"kbd\" x\n        let inline mark x = elem \"mark\" x\n        let inline q x = elem \"q\" x\n        let inline rp x = elem \"rp\" x\n        let inline rt x = elem \"rt\" x\n        let inline rtc x = elem \"rtc\" x\n        let inline ruby x = elem \"ruby\" x\n        let inline s x = elem \"s\" x\n        let inline samp x = elem \"samp\" x\n        let inline small x = elem \"small\" x\n        let inline span x = elem \"span\" x\n        let inline strong x = elem \"strong\" x\n        let inline sub x = elem \"sub\" x\n        let inline sup x = elem \"sup\" x\n        let inline time x = elem \"time\" x\n        let inline u x = elem \"u\" x\n        let inline var x = elem \"var\" x\n\n        // Image and multimedia\n        let inline audio x = elem \"audio\" x\n        let inline map x = elem \"map\" x\n        let inline video x = elem \"video\" x\n\n        // Embedded content\n        let inline objectHtml x = elem \"object\" x\n\n        // Demarcasting edits\n        let inline del x = elem \"del\" x\n        let inline ins x = elem \"ins\" x\n\n        // Table content\n        let inline caption x = elem \"caption\" x\n        let inline colgroup x = elem \"colgroup\" x\n        let inline table x = elem \"table\" x\n        let inline tbody x = elem \"tbody\" x\n        let inline td x = elem \"td\" x\n        let inline tfoot x = elem \"tfoot\" x\n        let inline th x = elem \"th\" x\n        let inline thead x = elem \"thead\" x\n        let inline tr x = elem \"tr\" x\n\n        // Forms\n        let inline button x = elem \"button\" x\n        let inline datalist x = elem \"datalist\" x\n        let inline fieldset x = elem \"fieldset\" x\n        let inline form x = elem \"form\" x\n        let inline label x = elem \"label\" x\n        let inline legend x = elem \"legend\" x\n        let inline meter x = elem \"meter\" x\n        let inline optgroup x = elem \"optgroup\" x\n        let inline option x = elem \"option\" x\n        let inline output x = elem \"output\" x\n        let inline progress x = elem \"progress\" x\n        let inline select x = elem \"select\" x\n        let inline textarea x = elem \"textarea\" x\n\n        // Interactive elements\n        let inline details x = elem \"details\" x\n        let inline dialog x = elem \"dialog\" x\n        let inline menu x = elem \"menu\" x\n        let inline menuitem x = elem \"menuitem\" x\n        let inline summary x = elem \"summary\" x\n\n    [<AutoOpen>]\n    module Attributes =\n        let inline attribute key value = Attribute.Attribute (key,value)\n        let inline property key value = Attribute.Property (key,value)\n\n        /// Class attribute helper\n        let inline Class value = attribute \"class\" value\n\n        /// Helper to build space separated class\n        let inline classList (list: (string*bool) seq) =\n            list\n                |> Seq.filter (fun (c,cond) -> cond)\n                |> Seq.map (fun (c, cond) -> c)\n                |> String.concat \" \"\n                |> Class\n\n        let inline boolAttribute name (value: bool) =\n            attribute name (string value)\n\n    [<AutoOpen>]\n    module Events =\n        let inline onMouseEvent eventType f = EventHandler (eventType, f)\n\n        let inline onMouseClick x = onMouseEvent \"onclick\" x\n        let inline onContextMenu x = onMouseEvent \"oncontextmenu\" x\n        let inline onDblClick x = onMouseEvent \"ondblclick\" x\n        let inline onMouseDown x = onMouseEvent \"onmousedown\" x\n        let inline onMouseEnter x = onMouseEvent \"onmouseenter\" x\n        let inline onMouseLeave x = onMouseEvent \"onmouseleave\" x\n        let inline onMouseMove x = onMouseEvent \"onmousemove\" x\n        let inline onMouseOut x = onMouseEvent \"onmouseout\" x\n        let inline onMouseOver x = onMouseEvent \"onmouseover\" x\n        let inline onMouseUp x = onMouseEvent \"onmouseup\" x\n        let inline onShow x = onMouseEvent \"onshow\" x\n        let inline onKeyboardEvent eventType f = EventHandler (eventType, f)\n        let inline onKeydown x = onKeyboardEvent \"onkeydown\" x\n        let inline onKeypress x = onKeyboardEvent \"onkeypress\" x\n        let inline onKeyup x = onKeyboardEvent \"onkeyup\" x\n\n        let inline onEvent eventType f = EventHandler (eventType, f)\n        let inline onAbort x = onEvent \"onabort\" x\n        let inline onAfterPrint x = onEvent \"onafterprint\" x\n        let inline onAudioEnd x = onEvent \"onaudioend\" x\n        let inline onAudioStart x = onEvent \"onaudiostart\" x\n        let inline onBeforePrint x = onEvent \"onbeforeprint\" x\n        let inline onCached x = onEvent \"oncached\" x\n        let inline onCanPlay x = onEvent \"oncanplay\" x\n        let inline onCanPlayThrough x = onEvent \"oncanplaythrough\" x\n        let inline onChange x = onEvent \"onchange\" x\n        let inline onChargingChange x = onEvent \"onchargingchange\" x\n        let inline onChargingTimeChange x = onEvent \"onchargingtimechange\" x\n        let inline onChecking x = onEvent \"onchecking\" x\n        let inline onClose x = onEvent \"onclose\" x\n        let inline onDischargingTimeChange x = onEvent \"ondischargingtimechange\" x\n        let inline onDOMContentLoaded x = onEvent \"onDOMContentLoaded\" x\n        let inline onDownloading x = onEvent \"ondownloading\" x\n        let inline onDurationchange x = onEvent \"ondurationchange\" x\n        let inline onEmptied x = onEvent \"onemptied\" x\n        let inline onEnd x = onEvent \"onend\" x\n        let inline onEnded x = onEvent \"onended\" x\n        let inline onError x = onEvent \"onerror\" x\n        let inline onCullScreenChange x = onEvent \"onfullscreenchange\" x\n        let inline onCullScreenError x = onEvent \"onfullscreenerror\" x\n        let inline onInput x = onEvent \"oninput\" x\n        let inline onInvalid x = onEvent \"oninvalid\" x\n        let inline onLanguageChange x = onEvent \"onlanguagechange\" x\n        let inline onLevelChange x = onEvent \"onlevelchange\" x\n        let inline onLoadedData x = onEvent \"onloadeddata\" x\n        let inline onLoadedMetaData x = onEvent \"onloadedmetadata\" x\n        let inline onNoUpdate x = onEvent \"onnoupdate\" x\n        let inline onObsolete x = onEvent \"onobsolete\" x\n        let inline onOffline x = onEvent \"onoffline\" x\n        let inline onOnline x = onEvent \"ononline\" x\n        let inline onOpen x = onEvent \"onopen\" x\n        let inline onOrientationChange x = onEvent \"onorientationchange\" x\n        let inline onPause x = onEvent \"onpause\" x\n        let inline onPointerlockchange x = onEvent \"onpointerlockchange\" x\n        let inline onPointerlockerror x = onEvent \"onpointerlockerror\" x\n        let inline onPlay x = onEvent \"onplay\" x\n        let inline onPlaying x = onEvent \"onplaying\" x\n        let inline onRateChange x = onEvent \"onratechange\" x\n        let inline onReadyStateChange x = onEvent \"onreadystatechange\" x\n        let inline onReset x = onEvent \"onreset\" x\n        let inline onSeeked x = onEvent \"onseeked\" x\n        let inline onSeeking x = onEvent \"onseeking\" x\n        let inline onSelectStart x = onEvent \"onselectstart\" x\n        let inline onSelectionChange x = onEvent \"onselectionchange\" x\n        let inline onSoundEnd x = onEvent \"onsoundend\" x\n        let inline onSoundStart x = onEvent \"onsoundstart\" x\n        let inline onSpeechEnd x = onEvent \"onspeechend\" x\n        let inline onSpeechStart x = onEvent \"onspeechstart\" x\n        let inline onStalled x = onEvent \"onstalled\" x\n        let inline onStart x = onEvent \"onstart\" x\n        let inline onSubmit x = onEvent \"onsubmit\" x\n        let inline onSuccess x = onEvent \"onsuccess\" x\n        let inline onSuspend x = onEvent \"onsuspend\" x\n        let inline onTimeUpdate x = onEvent \"ontimeupdate\" x\n        let inline onUpdateReady x = onEvent \"onupdateready\" x\n        let inline onVoicesChanged x = onEvent \"onvoiceschanged\" x\n        let inline onVisibilityChange x = onEvent \"onvisibilitychange\" x\n        let inline onVolumeChange x = onEvent \"onvolumechange\" x\n        let inline onVrdisplayConnected x = onEvent \"onvrdisplayconnected\" x\n        let inline onVrdisplayDisconnected x = onEvent \"onvrdisplaydisconnected\" x\n        let inline onVrdisplayPresentChange x = onEvent \"onvrdisplaypresentchange\" x\n        let inline onWaiting x = onEvent \"onwaiting\" x\n\n        let inline onBlur x = onEvent \"onblur\" x\n        let inline onFocus x = onEvent \"onfocus\" x\n\n    [<AutoOpen>]\n    module Svg = \n        let svgNS = Attribute.Property(\"namespace\",\"http://www.w3.org/2000/svg\")\n        let inline svgElem tagName attrs children = Element((tagName, svgNS::attrs), children)\n\n        let inline svg x = svgElem \"svg\" x\n        let inline circle x = svgElem \"circle\" x \n        let inline rect x = svgElem \"rect\" x \n\n        let inline width x = attribute \"width\" x\n        let inline height x = attribute \"height\" x\n        let inline viewBox x = attribute \"viewBox\" x\n        let inline cx x = attribute \"cx\" x\n        let inline cy x = attribute \"cy\" x\n        let inline r x = attribute \"r\" x\n        let inline stroke x = attribute \"stroke\" x\n        let inline strokeWidth x = attribute \"stroke-width\" x\n        let inline fill x = attribute \"fill\" x\n\nopen Html\nopen Fable.Import.Browser\n\n[<AutoOpen>]\nmodule App =\n    type Action<'TMessage> = ('TMessage -> unit) -> unit\n    type Producer<'TMessage> = ('TMessage -> unit) -> unit\n\n    let mapAction<'T1,'T2> (mapping:'T1 -> 'T2) (action:Action<'T1>) : Action<'T2> = \n        fun x -> action (mapping >> x)  \n\n    let mapActions m = List.map (mapAction m)\n    let toActionList a = [a]\n\n    type AppEvents<'TMessage, 'TModel> =\n        | ModelChanged of 'TModel*'TModel\n        | ActionReceived of 'TMessage\n        | DrawStarted\n\n    type Subscriber<'TMessage, 'TModel> = AppEvents<'TMessage, 'TModel> -> unit\n\n    type RenderState = \n        | InProgress\n        | NoRequest\n\n    type App<'TModel, 'TMessage> =\n        {\n            Model: 'TModel\n            View: 'TModel -> DomNode<'TMessage>\n            Update: 'TModel -> 'TMessage -> ('TModel * Action<'TMessage> list)\n            InitMessage : (('TMessage -> unit) -> unit) option\n            Actions: Action<'TMessage> list\n            Producers: Producer<'TMessage> list\n            Node: Node option\n            CurrentTree: obj option\n            Subscribers: Map<string, Subscriber<'TMessage, 'TModel>>\n            NodeSelector: string option\n            RenderState: RenderState\n        }\n\n    type ScheduleMessage = \n        | PingIn of float*(unit -> unit)\n\n    type AppMessage<'TMessage> =\n        | AddSubscriber of string*Subscriber<'TMessage, 'TMessage>\n        | RemoveSubscriber of string\n        | Message of 'TMessage\n        | Draw\n\n    type Renderer<'TMessage> =\n        {\n            Render: ('TMessage -> unit) -> DomNode<'TMessage> -> obj\n            Diff: obj -> obj -> obj\n            Patch: Fable.Import.Browser.Node -> obj -> Fable.Import.Browser.Node\n            CreateElement: obj -> Fable.Import.Browser.Node\n        }\n\n    let createApp model view update =\n        {\n            Model = model\n            View = view\n            Update = update\n            NodeSelector = None\n            InitMessage = None\n            Producers = []\n            Subscribers = Map.empty\n\n            CurrentTree = None\n            RenderState = NoRequest\n            Actions = []\n            Node = None\n        }\n\n    let createSimpleApp model view update =\n        createApp model view (fun x y -> (update x y), [])\n\n    let withStartNodeSelector selector app = { app with NodeSelector = Some selector }\n    let withInitMessage msg app = { app with InitMessage = Some msg }\n    let withProducer p app = \n        {app with Producers = p::app.Producers}\n    let withSubscriber subscriberId subscriber app =\n        let subsribers = app.Subscribers |> Map.add subscriberId subscriber\n        { app with Subscribers = subsribers }\n\n    let createScheduler() = \n        MailboxProcessor.Start(fun inbox ->\n            let rec loop() = \n                async {\n                    let! message = inbox.Receive()\n                    match message with\n                    | PingIn (milliseconds, cb) ->\n                        window.setTimeout(cb, milliseconds) |> ignore\n                        return! loop()\n                }\n            loop()\n        )\n\n    let createFirstLoopState renderTree (startElem:Node) post renderer state =\n        let tree = renderTree state.View post state.Model\n        let rootNode = renderer.CreateElement tree\n        startElem.appendChild(rootNode) |> ignore\n        match state.InitMessage with\n        | None -> ()\n        | Some init -> init post\n        {state with CurrentTree = Some tree; Node = Some rootNode}\n\n    let handleMessage msg notify schedule state = \n        ActionReceived msg |> (notify state.Subscribers)\n        let (model', actions) = state.Update state.Model msg\n\n        let renderState =\n            match state.RenderState with\n            | NoRequest ->\n                schedule()\n//                    scheduler.Post(PingIn(1000./60., (fun() -> inbox.Post(Draw))))\n                InProgress\n            | InProgress -> InProgress\n        {\n            state with \n                Model = model'\n                RenderState = renderState\n                Actions = state.Actions @ actions }\n\n    let handleDraw renderTree renderer post notify rootNode currentTree state = \n        match state.RenderState with\n        | InProgress ->\n            DrawStarted |> notify state.Subscribers\n            let model = state.Model\n            let tree = renderTree state.View post model\n            let patches = renderer.Diff currentTree tree\n            renderer.Patch rootNode patches |> ignore\n            state.Actions |> List.iter (fun i -> i post)\n            (ModelChanged (model, state.Model)) |> notify state.Subscribers\n            {state with RenderState = NoRequest; CurrentTree = Some tree; Actions = []}\n        | NoRequest -> raise (exn \"Shouldn't happen\")\n\n    let start renderer app =\n        let renderTree view handler model =\n            view model\n            |> renderer.Render handler\n\n        let startElem =\n            match app.NodeSelector with\n            | None -> document.body\n            | Some sel -> document.body.querySelector(sel) :?> HTMLElement\n\n        let scheduler = createScheduler()\n        MailboxProcessor.Start(fun inbox ->\n            let post message =\n                inbox.Post (Message message)\n            let notifySubscribers subs model =\n                subs |> Map.iter (fun key handler -> handler model)\n            app.Producers |> List.iter (fun p -> p post)\n            let schedule() = scheduler.Post(PingIn(1000./60., (fun() -> inbox.Post(Draw))))\n            let rec loop state =\n                async {\n                    match state.Node, state.CurrentTree with\n                    | None,_ ->\n                        let state' = createFirstLoopState renderTree startElem post renderer state\n                        return! loop state'\n                    | Some rootNode, Some currentTree ->\n                        let! message = inbox.Receive()\n                        match message with\n                        | Message msg ->\n                            let state' = handleMessage msg notifySubscribers schedule state\n                            return! loop state'\n                        | Draw -> \n                            let state' = handleDraw renderTree renderer post notifySubscribers rootNode currentTree state\n                            return! loop state'\n                        | _ -> return! loop state\n                    | _ -> failwith \"Shouldn't happen\"\n                }\n            loop app)\n\nlet createTree<'T> (handler:'T -> unit) tag (attributes:Attribute<'T> list) children =\n    let toAttrs (attrs:Attribute<'T> list) =\n        let elAttributes = \n            attrs\n            |> List.map (function\n                | Attribute (k,v) -> (k ==> v) |> Some\n                | _ -> None)\n            |> List.choose id\n            |> (function | [] -> None | v -> Some (\"attributes\" ==> (createObj(v))))\n        let props =\n            attrs\n            |> List.filter (function | Attribute _ -> false | _ -> true)\n            |> List.map (function\n                | Attribute _ -> failwith \"Shouldn't happen\"\n                | Style style -> \"style\" ==> createObj(unbox style)\n                | Property (k,v) -> k ==> v\n                | EventHandler(ev,f) -> ev ==> ((f >> handler) :> obj)\n            )\n\n        match elAttributes with\n        | None -> props\n        | Some x -> x::props\n        |> createObj\n    let elem = h(tag, toAttrs attributes, List.toArray children)\n    elem\n\nlet rec render handler node =\n    match node with\n    | Element((tag,attrs), nodes)\n    | Svg((tag,attrs), nodes) -> createTree handler tag attrs (nodes |> List.map (render handler))\n    | VoidElement (tag, attrs) -> createTree handler tag attrs []\n    | Text str -> box(string str)\n    | WhiteSpace str -> box(string str)\n\nlet renderer =\n    {\n        Render = render\n        Diff = diff\n        Patch = patch\n        CreateElement = createElement\n    }"]}